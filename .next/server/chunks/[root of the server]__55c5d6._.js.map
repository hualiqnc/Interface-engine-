{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///Users/truongngochuyen/Downloads/Assignment2-COS30019-main%20copy/src/lib/inference.ts"],"sourcesContent":["type Clause = {\n    antecedents: Expression[]\n    consequent: Expression\n}\n\ntype Expression = {\n    type: 'LITERAL' | 'NEGATION' | 'DISJUNCTION' | 'BICONDITIONAL'\n    value: string | Expression | Expression[]\n}\n\ntype KnowledgeBase = {\n    facts: Set<string>\n    rules: Clause[]\n}\n\nfunction parseExpression(expr: string): Expression {\n    expr = expr.trim()\n    \n    // Handle negation\n    if (expr.startsWith('~')) {\n        return {\n            type: 'NEGATION',\n            value: parseExpression(expr.slice(1))\n        }\n    }\n    \n    // Handle disjunction\n    if (expr.includes('||')) {\n        return {\n            type: 'DISJUNCTION',\n            value: expr.split('||').map(e => parseExpression(e.trim()))\n        }\n    }\n    \n    // Handle biconditional\n    if (expr.includes('<=>')) {\n        const [left, right] = expr.split('<=>').map(e => parseExpression(e.trim()))\n        return {\n            type: 'BICONDITIONAL',\n            value: [left, right]\n        }\n    }\n    \n    // Simple literal\n    return {\n        type: 'LITERAL',\n        value: expr\n    }\n}\n\nexport function parseInput(input: string): { kb: KnowledgeBase; query: string } {\n    const lines = input.split('\\n')\n    const kb: KnowledgeBase = { facts: new Set(), rules: [] }\n    let query = ''\n\n    let isTell = false\n    let isAsk = false\n\n    for (const line of lines) {\n        if (line.trim() === 'TELL') {\n            isTell = true\n            continue\n        } else if (line.trim() === 'ASK') {\n            isTell = false\n            isAsk = true\n            continue\n        }\n\n        if (isTell) {\n            const clauses = line.split(';').map((c) => c.trim()).filter((c) => c)\n            for (const clause of clauses) {\n                if (clause.includes('=>')) {\n                    const [antecedentsStr, consequentStr] = clause.split('=>').map((s) => s.trim())\n                    const antecedents = antecedentsStr.split('&').map((s) => parseExpression(s.trim()))\n                    const consequent = parseExpression(consequentStr)\n                    kb.rules.push({ antecedents, consequent })\n                } else {\n                    // Handle facts with new operators\n                    const expr = parseExpression(clause)\n                    if (expr.type === 'LITERAL') {\n                        kb.facts.add(expr.value as string)\n                    } else {\n                        kb.rules.push({ antecedents: [], consequent: expr })\n                    }\n                }\n            }\n        } else if (isAsk) {\n            query = line.trim()\n        }\n    }\n\n    return { kb, query }\n}\n\nfunction evaluateExpression(expr: Expression, assignment: Record<string, boolean>): boolean {\n    switch (expr.type) {\n        case 'LITERAL':\n            return assignment[expr.value as string] || false\n            \n        case 'NEGATION':\n            return !evaluateExpression(expr.value as Expression, assignment)\n            \n        case 'DISJUNCTION':\n            return (expr.value as Expression[]).some(e => evaluateExpression(e, assignment))\n            \n        case 'BICONDITIONAL':\n            const [left, right] = expr.value as Expression[]\n            const leftValue = evaluateExpression(left, assignment)\n            const rightValue = evaluateExpression(right, assignment)\n            return leftValue === rightValue\n            \n        default:\n            return false\n    }\n}\n\nfunction evaluateKB(kb: KnowledgeBase, assignment: Record<string, boolean>): boolean {\n    // Evaluate facts\n    for (const fact of kb.facts) {\n        if (!assignment[fact]) return false\n    }\n\n    // Evaluate rules\n    for (const rule of kb.rules) {\n        const antecedentsTrue = rule.antecedents.every(ant => \n            evaluateExpression(ant, assignment)\n        )\n        const consequentTrue = evaluateExpression(rule.consequent, assignment)\n        \n        if (antecedentsTrue && !consequentTrue) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function TruthTable(kb: KnowledgeBase, query: string): string {\n    const symbols = new Set<string>()\n    kb.facts.forEach(fact => symbols.add(fact))\n    kb.rules.forEach(rule => {\n        rule.antecedents.forEach(ant => {\n            if (ant.type === 'LITERAL') symbols.add(ant.value as string)\n        })\n        if (rule.consequent.type === 'LITERAL') symbols.add(rule.consequent.value as string)\n    })\n    symbols.add(query)\n\n    const symbolList = Array.from(symbols)\n\n    function generateTruthTable(n: number): boolean[][] {\n        if (n === 0) return [[]]\n        const subTable = generateTruthTable(n - 1)\n        return [...subTable.map(row => [false, ...row]), ...subTable.map(row => [true, ...row])]\n    }\n\n    const table = generateTruthTable(symbolList.length)\n    let modelCount = 0\n    let totalModels = 0\n\n    for (const row of table) {\n        const assignment = Object.fromEntries(symbolList.map((sym, i) => [sym, row[i]]))\n        if (evaluateKB(kb, assignment)) {\n            totalModels++\n            if (assignment[query]) {\n                modelCount++\n            }\n        }\n    }\n\n    return modelCount > 0 ? `YES: ${modelCount}` : 'NO'\n}\n\nfunction isHornClause(rule: Clause): boolean {\n    // A Horn clause can only have one positive literal (consequent)\n    // All antecedents must be positive literals\n    return rule.antecedents.every(ant => \n        ant.type === 'LITERAL' && \n        typeof ant.value === 'string'\n    ) && \n    rule.consequent.type === 'LITERAL' && \n    typeof rule.consequent.value === 'string'\n}\n\nfunction isHornKB(kb: KnowledgeBase): boolean {\n    // Check if all rules are Horn clauses\n    return kb.rules.every(isHornClause)\n}\n\nexport function ForwardChaining(kb: KnowledgeBase, query: string): string {\n    // First check if KB is in Horn form\n    if (!isHornKB(kb)) {\n        return \"NO: Knowledge base is not in Horn form. Use Truth Table method instead.\"\n    }\n\n    const entailed = new Set(kb.facts)\n    const agenda = [...kb.facts]\n    const steps: string[] = []\n    let stepCount = 1\n\n    // Check if query is in initial facts\n    if (entailed.has(query)) {\n        return `YES: ${[...entailed].join(', ')}\\n\\nReasoning:\\nQuery '${query}' was found in initial facts.`\n    }\n\n    while (agenda.length > 0) {\n        const p = agenda.pop()!\n        steps.push(`${stepCount}. Examining fact: ${p}`)\n        stepCount++\n\n        if (p === query) {\n            return `YES: ${[...entailed].join(', ')}\\n\\nReasoning:\\n${steps.join('\\n')}\\n\\nExplanation:\\nStarting from initial facts, we applied Horn rules to derive new facts until we found '${query}'.`\n        }\n\n        // Try to derive new facts using Horn rules\n        for (const rule of kb.rules) {\n            const consequentValue = rule.consequent.value as string\n            \n            if (consequentValue === query && entailed.has(query)) {\n                continue\n            }\n\n            // Check if all antecedents are satisfied\n            if (rule.antecedents.every(ant => entailed.has(ant.value as string)) && \n                !entailed.has(consequentValue)) {\n                entailed.add(consequentValue)\n                agenda.push(consequentValue)\n                steps.push(`${stepCount}. Applied Horn rule: ${rule.antecedents.map(a => a.value).join(' & ')} => ${consequentValue}`)\n                stepCount++\n\n                if (consequentValue === query) {\n                    return `YES: ${[...entailed].join(', ')}\\n\\nReasoning:\\n${steps.join('\\n')}\\n\\nExplanation:\\nStarting from initial facts, we applied Horn rules to derive new facts until we found '${query}'.`\n                }\n            }\n        }\n    }\n\n    return `NO\\n\\nReasoning:\\n${steps.join('\\n')}\\n\\nExplanation:\\nAfter exhausting all possible Horn rule inferences, we could not derive '${query}'.`\n}\n\nexport function BackwardChaining(kb: KnowledgeBase, query: string): string {\n    // First check if KB is in Horn form\n    if (!isHornKB(kb)) {\n        return \"NO: Knowledge base is not in Horn form. Use Truth Table method instead.\"\n    }\n\n    const entailed = new Set<string>()\n    const steps: string[] = []\n    let stepCount = 1\n\n    function backchain(goal: string, visited: Set<string>): boolean {\n        if (visited.has(goal)) {\n            steps.push(`${stepCount++}. Skipping ${goal} (already visited)`)\n            return false\n        }\n        visited.add(goal)\n        steps.push(`${stepCount++}. Attempting to prove Horn clause goal: ${goal}`)\n\n        if (kb.facts.has(goal)) {\n            steps.push(`${stepCount++}. Found ${goal} in facts`)\n            entailed.add(goal)\n            return true\n        }\n\n        // Only consider Horn rules\n        for (const rule of kb.rules) {\n            if (rule.consequent.value === goal) {\n                steps.push(`${stepCount++}. Found Horn rule: ${rule.antecedents.map(a => a.value).join(' & ')} => ${goal}`)\n                if (rule.antecedents.every(ant => backchain(ant.value as string, new Set(visited)))) {\n                    entailed.add(goal)\n                    steps.push(`${stepCount++}. Successfully proved ${goal} using Horn rule`)\n                    return true\n                }\n            }\n        }\n\n        steps.push(`${stepCount++}. Failed to prove ${goal} using Horn rules`)\n        return false\n    }\n\n    const result = backchain(query, new Set())\n    return result \n        ? `YES: ${[...entailed].join(', ')}\\n\\nReasoning:\\n${steps.join('\\n')}\\n\\nExplanation:\\nWorking backwards from the query '${query}', we successfully proved all required subgoals using Horn rules.`\n        : `NO\\n\\nReasoning:\\n${steps.join('\\n')}\\n\\nExplanation:\\nWorking backwards from '${query}', we could not establish a complete proof chain using Horn rules.`\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///Users/truongngochuyen/Downloads/Assignment2-COS30019-main%20copy/src/app/api/infer/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { parseInput, TruthTable, ForwardChaining, BackwardChaining } from '@/lib/inference'\n\nexport async function POST(req: Request) {\n    const { input, method } = await req.json()\n    const { kb, query } = parseInput(input)\n\n    let result\n    switch (method) {\n        case 'TT':\n            result = TruthTable(kb, query)\n            break\n        case 'FC':\n            result = ForwardChaining(kb, query)\n            break\n        case 'BC':\n            result = BackwardChaining(kb, query)\n            break\n        default:\n            return NextResponse.json({ error: 'Invalid method' }, { status: 400 })\n    }\n\n    return NextResponse.json({ result })\n}"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,eAAe,KAAK,GAAY;IACnC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,IAAI;IACxC,MAAM,EAAE,EAAE,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,yHAAA,CAAA,aAAU,AAAD,EAAE;IAEjC,IAAI;IACJ,OAAQ;QACJ,KAAK;YACD,SAAS,CAAA,GAAA,yHAAA,CAAA,aAAU,AAAD,EAAE,IAAI;YACxB;QACJ,KAAK;YACD,SAAS,CAAA,GAAA,yHAAA,CAAA,kBAAe,AAAD,EAAE,IAAI;YAC7B;QACJ,KAAK;YACD,SAAS,CAAA,GAAA,yHAAA,CAAA,mBAAgB,AAAD,EAAE,IAAI;YAC9B;QACJ;YACI,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;IAC5E;IAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE;IAAO;AACtC"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}